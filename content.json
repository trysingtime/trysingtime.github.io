[{"title":"计算机网络的繁花","date":"2024-02-22T07:16:36.301Z","path":"2024/02/22/计算机网络的繁花/","text":"MAC 和 IP 地址当下计算机发展火热，每年不计其数的学生投奔这个行业，匆匆忙忙学一门编程语言，急急忙忙找一份工作。平时对于工作内容滚瓜烂熟，但是总感觉自己基础并不牢固，想要夯实基础，却又无从着手。平时碎片时间学到了很多，但知识点总是串不起来。这非常正常，计算机这几十年的迅猛发展，带来了巨量的知识内容，甚至每天都在更新全新的技术。滚滚车轮下，没人可以了解一切，人们只是在不断追逐。万幸的是，计算机并不同于自然科学，自然科学通常究其根源是无解的，或者说当下无解。但计算机不同，它是人类一手发展起来的，它是有明确的原理和根源的，只要你将探究的目的限制于计算机体系而不是其物理原理，那么一切都是有解的。整个计算机体系基于相同的源头，已经形成了许多重要的支柱，所有的一切新的技术都在支柱之上伸展。大家面对汹涌的潮流，更应该做的是抓住支柱，从支柱出发学习，蔓延到感兴趣的一切目的地。计算机网络就是其中一大支柱，这是一个及其繁荣的体系，涉及名词繁多。如果每次学习总是只看到一片树叶，而不知其全貌未免太过可惜。其实说来复杂，但计算机网络也就几十年的历史，不如我们跟随发展的脉络，分析发展中遇到了什么问题，使用了什么技术解决问题，导致了什么结果。顺着这样的思路，我们能看到整个计算机网络体系从发芽到开枝散叶，直到开出繁花。 我们联合让我们回到计算机网络的蛮荒时期，此时，我们面临的情况很简单：大学实验室里有几台新奇的玩意叫计算机，有同学希望能否将其中一台计算机的计算结果拿到另一台计算机中使用。要实现其实并不困难，如果是打孔计算机，那么只需要将计算结果打孔纸条，然后将纸条拿到另一台计算机读取即可。可是有同学嫌麻烦，他认为这样效率太低，还需要自己动手，于是他有了自己的想法： 计算机计算结果是电信号 另一台计算机使用的也是电信号 如果能直接连接两台计算机的电信号，那么就不需要使用纸条作为中间介质 使用电缆连接两台计算机的某个引脚 编写计算机程序，使源计算机将计算结果输出到指定引脚 编写计算机程序，使目的计算机读取指定引脚的输入 将上述控制电信号的硬件和软件封装起来，并给这个设备取个名字，就叫控制器 将控制器装到实验室的每台计算机上，每个计算机都可以将计算结果传给其他计算机，把这个行为就做通信，整个体系我们称为网络 最后随着时间发展，控制器逐渐有了更明确的名称：网络接口控制器，简称网卡看！网络雏形出现了，后续网络体系发展的及其庞大，人们为了方便，将计算机分层，有7层的，也有5层的，不管怎样，上述体系一般都会分配到计算机网络体系的最底层，一般称为网络接口层。 你的名字相信聪明的小伙伴们看出来了，上述描述中两台计算机直接通过电缆通信是很合理的，计算机直接将计算结果通过电信号传给另一台计算机。但是当实验室中所有的计算机都接入了电缆，电缆形成了网状结构后，计算结果就传给所有其他计算机了，但是我不想影响到其他同学们的计算机，只想把我的计算结果传递给最好的同学小明同学，那应该怎么办。没错，不知不觉中，我们已经了解到了“广播”的概念，广播这个概念出现是非常顺理成章的，网络通讯控制反而才是网络使用中出现的新问题。为了解决这个问题，人们很自然的给每个计算机取名字&#x2F;编号。这台计算机是A,那台计算机是小明同学的，那台叫他 beta 好了，还有那台又破又慢，就叫“垃圾”好了…不管怎样，计算机们第一次有了身份标识，用于在计算机网络中表明自身。此时，beta 的计算结果打算传给小明同学，那么它只需要在结果前面附上自己的代号以及目标的代号：beta|小明同学，然后电信号通过电缆广播出去，所有计算机都会收到消息，并核对是不是发给自己的，如果不是则丢弃，只有小明同学才需要去获取这条消息。很多同学已经恍然大悟，这不就是MAC地址吗？是的，将计算机的代号规范化后固定为48位(6字节)，我们就得到了 MAC(Media Access Control) 地址，在实际应用中 MAC 地址是在网卡生产时写入到 ROM 里的。跟beta在计算结果前面添加“beta|小明同学”类似，在计算机网络中，每次通信都需要在消息前面添加 MAC 头部，格式为：接收方 MAC 地址(48位)，发送方 MAC 地址(48位)，协议类型(16位)。其中协议类型(16位)是用来告诉通信目标我这次传输的是什么类型的消息。用于标识上层协议的类型。常见的协议类型数值包括： 0x0800：表示上层协议是 IPv4。 0x86DD：表示上层协议是 IPv6。 0x0806：表示上层协议是 ARP（地址解析协议）。 0x0808：表示上层协议是帧中继（Frame Relay）。 0x8100：表示上层协议是 VLAN 标记（Virtual LAN Tagging） 既生瑜何生亮随着实验室计算机的增加，每次像发送消息给小明同学都要广播给所有计算机显得越来越愚蠢了。于是，你灵光一闪——集权，没错，你打算增加一个控制设备，所有的计算机都接入这台设备，它就是邮局，每台计算机发送消息就去邮局投递信件，说清楚你要将信件寄给小明同学，这样控制设备就直接将信件交给目标，不再打扰其他同学们干活了。这个设备不如就叫交换机吧。但这样一来，交换机上肯定得清楚地知道实验室里面都有多少台计算机，每台计算机叫什么，不然它也没法将信件交给准备的目标。因此交换机上维护了一张清单，里面登记了所有计算机的 MAC 地址以及其对应的端口，每次收到信件，交换机就查询这张清单上对应 MAC 地址的端口，将信件发过去，我们把这张清单叫做 MAC 地址表，或者路由表。问题再次得到了解决，直到隔壁某一天，你需要和隔壁学校合作，将你计算机的计算结果传给隔壁学校的计算机。此时，方法可以很粗暴，直接拉一条电缆将对方计算机接入你实验室所在的网络，同时也在 MAC 地址表上添加记录。不久，小明同学也参加了项目，需要和对方另一台计算机通信，你发现不对劲了，不能每多一位同学就拉一条电缆，其他不说，就显得很蠢。庆幸的是隔壁学校的同学们也很聪明，也使用了交换机控制通信。那么你们只需要将双方的交换机连接在一起，相互同步自身的 MAC 地址表，发现目标地址是隔壁学校的，就将信件交给对方的交换机，让对方代为转交。问题得到了解决，很快，两个学校的合作事迹传遍全城，所有学校都急忙加入了进来，数量庞大的计算机都接入了网络，MAC 地址表越来越臃肿了。并且，很多学校并不愿意公开自己内部的计算机信息，地址表的信息开始失真，MAC 地址表的维护变成了新的问题。 基于上述问题，一个天才般的方案诞生了。中心思想是分治，每个学校自己管理内部的计算机，学校之间通信则使用学校名+计算机名，其中计算机名由学校自己分配，这个方案就是大名鼎鼎的IP（Internet Protocol）协议。其中学校名+计算机名推广为网络号+主机号，网络号负责标识 IP 地址属于哪个学校，主机号负责标识同一个学校下的计算机。 总长度定为了32位，分成了四段(比如192.168.1.1)。同时为了使得网络号长度可变，添加了子网掩码。例如子网掩码255.255.255.0，转为二进制是「11111111-11111111-11111111-00000000」，也就是说网络号的长度为24，主机号的长度为8，一个完整的 IP 地址表示为 192.168.1.1&#x2F;24，其中&#x2F;24表示子网掩码255.255.255.0。只要将 IP 地址和子网掩码按位与运算就能得到网络号，将 IP 地址和子网掩码取反后进行按位与运算就能得到主机号。回到学校问题上，不同学校使用不同的网络号，内部自由分配主机号。通信时，交换机发现目标 IP 地址是相同网络号的，就可以使用维护的 MAC 地址表，或者使用新的 IP 地址表将信件传递给目标。如果发现目标 IP 网络号对不上，那么就转发给网络号对应的另一个学校的交换机即可。对了，此时交换机需要提供寻址和路由功能，此时应该将其称为路由器会更加合适。","tags":[]},{"title":"使用Windows11神器WSL打造独一无二的开发环境","date":"2024-02-07T16:00:00.000Z","path":"2024/02/08/使用Windows11神器WSL打造独一无二的开发环境/","text":"使用Windows11神器WSL打造独一无二的开发环境2024年只推荐WSL2相信每个开发人员都有自己一套开发习惯，有常用的开发工具，顺手的各种设定。而选择一个适合自己的操作系统，更是一切的基础。总体来说，可选的操作系统就三大类：Windows, MacOS, Linux，三个系统各有各的优缺点，在我看来Windows大而全，但稍显臃肿；MacOS优雅，兼具美观和高效，但价格昂贵且规矩繁多；Linux主打自由灵活，最接近生产环境，但是用户界面并不友好。 本人三个系统都使用过，在WSL出来之前实在难以抉择，但是2024年了，经过几年的使用，我强烈推荐基于WSL打造自己的开发环境，能兼顾Windows和Linux的优点。 WSL全称Windows Subsystem for Linux，是基于Windows Hyper-V平台的Linux虚拟机系统。Hyper-V是Windows自带的虚拟机平台，类似与大家可能更加熟悉的VMware，不过实话说，没VM好用，但胜在Windows自带且免费。所以说，本质上WSL就是虚拟机，不过是非常轻量的虚拟机，启动只需几秒。 WSL分为WSL1和WSL2： WSL1更加轻量，本质是转译，将Linux系统调用转为Windows系统调用，直接使用Windows本身的文件系统，所以数据操作性能很好。因为是转译的，所以存在Linux兼容性问题。 WSL2是完整的Linux虚拟机，和Windows本体（Host）隔离的更好，但也意味着和Host的互操作性较差。古早的版本想要操作Host的文件以及网络会面临诸多问题，不过经过这几年的更新，大部分问题都已经比较好地得到了解决。所以2024年更加推荐使用WSL2。 额外的功能开启WSL需要同时开启Windows的Hyper-V虚拟机，基于Hyper-V还有两个好用的功能。 Windows Sandbox: Windows自带沙盒软件，有什么风险操作例如未知的软件都可以放到里面执行，用完关掉，不留下任何痕迹。 WSA(Windows Subsystem for Android): Windows上运行安卓app。 效果展示 如图所示，在Windows上开启WSL2后，我在此之上运行了诸多Linux系统。每个系统用于一种特定的功能，例如Java这个系统安装了Java开发用到的各种环境和软件，Python这个环境安装了CUDA环境。其实就是虚拟机的用法，但是因为WSL2非常轻量，用起来更像是在使用Docker。说起Docker在上面的Ubuntu和Python这两个系统中分别独立安装了Docker。所以整个开发环境分成了三层： Windows 11: 用于运行GUI软件，例如开发工具IDEA, VS Code，Navicat等。 WSL2: 用于编译、执行代码，提前配置好运行环境，也可用作测试环境。 Docker：跟WSL2作用类似，不过基于Docker丰富的生态，可以更方便的使用各类容器，包括Mysql, Redis等都能直接使用，虽说有性能问题，但是非常便于开发。 此外，因为WSL2本质是虚拟机，可以非常容易地对整个系统进行备份和还原，所以不用担心因为各种骚操作搞崩自己的系统。重装系统后也可以迅速还原整个开发环境，再也不用担心哪些系统崩溃。 打造过程1. 开启 WSL21.1 开启 BIOS 的虚拟化确保 BIOS 中虚拟化选项开启。这个如果没有开启的话，需要进电脑的 BIOS 设置里开启，因为 intel 和 AMD 平台的不一样，具体可以搜索下。 1.2 启用Windows功能1.2.1 命令行以管理员方式打开 PowerShell 并运行： 12dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Windows-Subsystem-Linux &#x2F;all &#x2F;norestartdism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:VirtualMachinePlatform &#x2F;all &#x2F;norestart 执行完毕后重启生效。 1.2.2 图形界面当然你也可以选择图形化界面操作。按下 Win+R 组合键，键入 optionalfeatures。 按下图勾选Windows虚拟机平台和Hyper-V以及Linux子系统。 点击OK后，Windows会自动下载，并提示你重启，重启后即再继续后续操作。 2. 安装Linux2.1 命令行以管理员方式打开 PowerShell 并运行： 1wsl --install -d Ubuntu 2.2 微软商店打开微软商店，搜索Linux选择你喜欢的安装即可。 3. 配置Linux推荐直接使用WSL2，以管理员方式打开 PowerShell 并运行将WSL默认版本设置为WSL2： 1wsl --set-default-version 2 安装完后会在开始菜单中出现Ubuntu，直接点击打开即可，此时会让你输入用户名和密码。此时请注意，将你常用的Linux设定弄好，因为接下来，这个Linux系统将会作为其他后续所有Linux系统的模板，继承所有的设定。 4. 使用Linux镜像此时的Linux是安装在C盘的，如果后续继续安装其他系统，也都是继续安装在C盘，这是难以接受的。因此我们需要将已经安装的Linux导出，并卸载掉已经安装的这个Linux。 4.1 导出Linux镜像以管理员方式打开 PowerShell 并运行 12# wsl --export &lt;要导出的Linux名称&gt; &lt;导出的路径&gt;wsl --export Ubuntu E:\\Hyper-V\\Backup\\ubuntu.tar 等待一会，Linux就已经备份好了。 4.2 删除已经安装的Ubuntu直接当成普通APP删除即可。 4.3 导入Linux镜像12# wsl --import &lt;要使用的Linux名称&gt; &lt;安装Linux到哪个路径&gt; &lt;要导入的镜像路径&gt; &lt;版本号(2：代表wsl2)&gt;wsl --import Java E:\\Hyper-V\\WSL\\Java E:\\Hyper-V\\Backup\\ubuntu.tar --version 2 d7c056aa-7f9a-4d45-9665-15d2061a434b 此时安装的路径下面将会看到多了一个ext4.vhdx文件，这就是你虚拟机文件，非常方便管理。 4.4 导入多个Linux系统使用同样的方法，导入名称为Python、NodeJS的多个镜像。然后安装好各自需要的软件，配置好环境。此时可以再次对这些镜像进行备份，以后就不再需要每次重复配置环境啦。 4.5 使用第三方工具完成上面操作虽然有第三方工具可以实现上述所有操作，但其实本质还是上述那些步骤，没有方便多少，按照上述步骤来更容易理解原理。当然如果确实觉得麻烦，推荐下面这个第三方开源工具使用: GitHub - bostrot&#x2F;wsl2-distro-manager: A GUI to quickly manage your WSL2 instances 5. 安装Windows Terminal推荐使用这个美观好用的终端，直接使用微软商店安装即可，安装完成后，会自动识别到当下存在哪些WSL系统。 6. 安装 Docker建议创建一个新的WSL系统，例如名字为Docker。其实Docker本来就有Windows版本，Docker Desktop on Windows。不过这个安装侵入性太强，影响当前的Windows系统，我更倾向于在WSL2中当成普通的Linux安装Docker。详细安装步骤直接去官网查看Ubuntu的安装步骤即可。 7. 使用 CUDAWSL2 中也支持直接调用 Nvidia 的 GPU 使用 CUDA。 7.1 前提 Pascal 及其后的 GPUs. Windows 11 系统 安装了最新的 Nvidia CUDA 驱动 7.2 安装步骤1234567sudo apt-key del 7fa2af80 # 移除旧KEYwget https:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;compute&#x2F;cuda&#x2F;repos&#x2F;wsl-ubuntu&#x2F;x86_64&#x2F;cuda-keyring_1.1-1_all.debsudo dpkg -i cuda-keyring_1.1-1_all.debsudo apt-get updatesudo apt-get -y install cuda-toolkit-12-3nvidia-smi # 验证安装是否生效 7.3 WSL2 的 Docker 中使用 CUDA上面操作完成后，直接运行docker就行 1docker run -it --gpus&#x3D;all --rm nvidia&#x2F;cuda:11.4.2-base-ubuntu20.04 nvidia-smi 8. 通过配置文件让WSL2更好用WSL有两种配置文件，分别是主机上的配置文件和虚拟机的配置文件。但请注意，修改配置文件后需要完全关闭WSL8秒后才会生效。你可以通过命令关闭虚拟机: 12wsl --shutdown # 完全关闭WSLwsl --terminate &lt;虚拟机名称&gt; # 关闭特定虚拟机 详情可以参阅官方文档:. Advanced settings configuration in WSL | Microsoft Learn](https://learn.microsoft.com/en-us/windows/wsl/wsl-config)[Advanced settings configuration in WSL | Microsoft Learn](https://learn.microsoft.com/en-us/windows/wsl/wsl-config) 8.1 主机配置文件(不推荐改动)你可以通过.wslconfig 文件更改WSL的全局选项，这个文件在用户文件夹的根目录下（即 C:\\Users\\&lt;YourUserName&gt;\\.wslconfig）。 如果没有该文件，则新建一个，示例如下: [wsl2] # 自定义 Linux 内核的绝对路径 kernel&#x3D; # 给 WSL 2 虚拟机分配的内存大小 memory&#x3D; # 为 WSL 2 虚拟机分配的处理器核心数量 processors&#x3D; # 为 WSL 2 虚拟机分配的交换空间，0 表示没有交换空间 swap&#x3D; # 自定义交换虚拟磁盘 vhd 的绝对路径 swapFile&#x3D; # 是否允许将 WSL 2 的端口转发到主机（默认为 true） localhostForwarding&#x3D; # &lt;path&gt; 必须是带反斜杠的绝对路径，例如 C:\\\\Users\\\\kernel # &lt;size&gt; 必须在后面加上单位，例如 8 GB 或 512 MB Win 11 23H2 史诗级更新 WSL2 到 2.0 版本，带来了以下特性： 支持自动回收内存 支持自动释放 WSL2 虚拟硬盘空间 支持和 Windows 使用相同的网络（镜像网络） 支持 DNS Tunneling 支持 Windows 设置的代理 支持 Windows 防火墙 支持 Multicast 1234567[experimental]autoMemoryReclaim&#x3D;gradualnetworkingMode&#x3D;mirroreddnsTunneling&#x3D;truefirewall&#x3D;trueautoProxy&#x3D;truesparseVhd&#x3D;true 需要手动开启硬盘空间回收 1wsl --manage Ubuntu --set-sparse true 另外，使用 VSCode - WSL 插件的，建议去 VSCode 设置里把自动端口转发关掉（Remote: Auto Forward Ports），避免冲突，因为 WSL2 更新之后新的网络已经是和你的 Windows 使用相同网络了，不再需要端口转发了。 最后，如果你在 WSL 里使用 docker，那需要将 autoMemoryReclaim 配置为 dropcache 或者 disabled，然后在 /etc/docker/daemon.json 里添加一句 &quot;iptables&quot;: false ，否则你可能无法正常使用 docker。 8.2 虚拟机配置文件(推荐配置)可以登录虚拟机，通过&#x2F;etc&#x2F;wsl.conf更改WSL的虚拟机配置。如果没有该文件，则新建一个。 开启systemd 12[boot]systemd&#x3D;true 虚拟机中加载windows的文件 12345[automount]enabled &#x3D; trueroot &#x3D; &#x2F;mnt&#x2F; # 要加载到哪个路径(例如C盘被加载到&#x2F;mnt&#x2F;c&#x2F;)options &#x3D; &quot;metadata,umask&#x3D;22,fmask&#x3D;11&quot; # 解决windows文件权限问题mountFsTab &#x3D; false 虚拟机中关闭windows的环境变量PATH(容易影响环境变量问题) 123[interop]enabled&#x3D;trueappendWindowsPath&#x3D;false # 关闭PATH环境变量 修改虚拟机默认用户 12[user]default&#x3D;xxx 示例配置文件如下： 123456789101112[automount]enabled &#x3D; trueroot &#x3D; &#x2F;mnt&#x2F;options &#x3D; &quot;metadata,umask&#x3D;22,fmask&#x3D;11&quot;mountFsTab &#x3D; false[interop]enabled&#x3D;trueappendWindowsPath&#x3D;false[user]default&#x3D;xxx 9. WSL 常见问题9.1 某些低位端口无法使用 Hyper-V默认会占用掉低位端口，并且是随机使用的，很可能今天某个低位端口正常，突然有一天端口就无法使用了。 12345678910# 系统默认的端口占用范围；❯ netsh int ipv4 show dynamicport tcpProtocol tcp Dynamic Port Range---------------------------------Start Port : 1024Number of Ports : 64511# 开启hyper-v也会占用部分端口netsh interface ipv4 show excludedportrange protocol&#x3D;tcp 9.2 Proxifie 软件和 WSL2 的端口冲突报错如下： Theattempted operation is not supported for the type of object referenced. 使用命令 netsh winsockrese重置修复 9.3 WSL2 中 VIM 复制到 Windows 的剪切板在 .vimrc 文件中添加以下内容 12345678&quot; WSL yank supportlet s:clip &#x3D; &#39;&#x2F;mnt&#x2F;c&#x2F;Windows&#x2F;System32&#x2F;clip.exe&#39; &quot; change this path according to your mount pointif executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * if v:event.operator &#x3D;&#x3D;# &#39;y&#39; | call system(s:clip, @0) | endif augroup ENDendif 9.4 直接与宿主 Windows 系统通信12# 直接放开 &#96;vEthernet (WSL)&#96; 这张网卡的防火墙New-NetFirewallRule -DisplayName &quot;WSL&quot; -Direction Inbound -InterfaceAlias &quot;vEthernet (WSL)&quot; -Action Allow 9.5 压缩磁盘占用1Optimize-VHD -Path E:\\Hyper-V\\WSL\\Ubuntu\\ext4.vhdx -Mode full","tags":[{"name":"Dev Env","slug":"Dev-Env","permalink":"https://blog.yuifly.top/tags/Dev-Env/"},{"name":"WSL","slug":"WSL","permalink":"https://blog.yuifly.top/tags/WSL/"},{"name":"Windows 11","slug":"Windows-11","permalink":"https://blog.yuifly.top/tags/Windows-11/"}]},{"title":"Hello World","date":"2024-01-04T06:55:22.533Z","path":"2024/01/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]