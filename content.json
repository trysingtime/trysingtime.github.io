[{"title":"Java 性能分析和线上监控-Arthas","date":"2024-02-08T16:00:00.000Z","path":"2024/02/09/Java 性能分析和线上监控-Arthas/","text":"Java 性能分析和线上监控-Arthas什么是Arthas Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。 总结来说就是可以查看、修改运行中的 Java 应用。 什么时候需要 Arthas 了解当前 Java 应用的性能 查看当前 Java 应用的瓶颈 监控 JVM 的运行状态 线上修改日志 测试环境直接修改代码 定位应用热点，生成火焰图 Arthas 常用命令小结 help - 查看支持哪些指令 memory - 查看 JVM 内存信息 thread - 查看线程 CPU 使用率 cls - 清空当前屏幕 logger - 查看并修改日志信息 stack - 查看方法的调用栈 watch - 查看方法的调用情况包括参数和返回值 tract - 查看方法的调用栈运行时间 monitor - 统计一段时间内的方法的调用次数、平均运行时间、成功&#x2F;失败次数 tt - watch的升级版，支持先把方法调用全记录下来，后续再排查 profiler - 生成火焰图 sc&#x2F;sm&#x2F;jad&#x2F;mc&#x2F;redefine - 线上查找并修改class Arthas 常用命令示例 查看方法的调用栈(-n 2 表示查看两次) 1stack com.yjt.ccb.controller.ExchangeController invoke -n 2 查看方法的参数和返回值(-x 3 表示调用栈深度) 1watch com.yjt.ccb.controller.ExchangeController invoke &#39;&#123;params,returnObj,throwExp&#125;&#39; -n 2 -x 3 查看方法栈运行时间(–skipJDKMethod false 表示包含 JDK 的调用栈) 1trace com.yjt.ccb.controller.ExchangeController invoke -n 2 --skipJDKMethod false 统计方法运行平均用时(–cycle 10 表示10秒一次) 1monitor com.yjt.ccb.controller.ExchangeController invoke -n 10 --cycle 10 查看 JVM 内存信息 1memory 最佳实践 使用插件自动生成指令 为了使 Arthas 更易用，我们可以使用 IDEA 的插件 - arthas idea - IntelliJ IDEs Plugin | Marketplace 安装后，我们在需要使用 Arthas 命令的方法上右键就能看到 Arthas 菜单，可以根据需要自动生成上述各种 Arthas 的指令。 在 Springboot 中集成 Arthas在 Spring 应用中集成 Arthas，应用启动时，Arthas 也会跟着启动，同时也启动了 Arthas Console， 其实就是网页版。 配置 maven 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.taobao.arthas&lt;&#x2F;groupId&gt; &lt;artifactId&gt;arthas-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;arthas.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 配置 springboot 123456spring.arthas.enabled&#x3D;truearthas.ip&#x3D;0.0.0.0arthas.telnet-port&#x3D;13658arthas.http-port&#x3D;18563arthas.username&#x3D;arthasarthas.password&#x3D;arthas 网页控制台使用 打开网页 http://localhost:18563","tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://blog.yuifly.top/tags/Arthas/"},{"name":"Java","slug":"Java","permalink":"https://blog.yuifly.top/tags/Java/"}]},{"title":"白嫖GPT4 Turbo 128K","date":"2024-02-08T16:00:00.000Z","path":"2024/02/09/白嫖GPT4 Turbo 128K/","text":"白嫖GPT4 Turbo 128K相信不少人已有GPT及类似技术产品的体验。本人也基本把市面上的产品体验过了一轮，无论国内还是国外的。但是Tiktok的这个产品coze(https://coze.com)还是值得大家试试。最大的特点就是免费，对！你没看错，白嫖。更何况coze基于免费，竟然号称可以使用GPT 4 Turbo 128K。赶紧上去试试。 说人话，COZE是什么一句话总结COZE是免费的GPT。它与市场上的其他产品有什么不同？有！它不是开箱即用，COZE要求用户在开始对话前设定角色，即创建一个机器人（BOT）。COZE国内版也上线了，采用的是语雀，但若要体验搭载GPT4的版本，还是推荐使用国际版。当然，国际版的使用需要科学上网，你懂的。 对比其他产品，为什么使用COZE 免费！！！ COZE不仅免费，而且提供了与GPT4媲美的性能。 创建多个BOT COZE允许用户创造多个BOT，每个BOT可以完成特定任务，如A BOT负责中英文翻译，B BOT则是编程助理。这使得每个BOT能专注并精通于其任务。当然你也可以不给BOT添加任何限制，这样的话就跟使用GPT非常相似。 接入各大平台的机器人 你可以将BOT发布到各大平台，如Telegram, Discord等，让COZE帮助你轻松地将AI BOT部署到这些平台上。 可以拼接多个BOT形成工作流。 通过拼接多个BOT，你可以创建一系列自动化的工作流程。 可以上传自己的资料，形成知识库。 可以使用已有的各种插件让BOT拥有更多能力包括联网等。 可以使用定时触发。 怎么使用 COZE的使用算得上是入门容易精通困难。这里我们先使用最简单的流程大致过一遍怎么使用，后面章节再来深入使用。 注册 创建BOT 创建过程非常简单，这里简介就不填写了，头像可以使用AI直接生成，非常方便。 使用 没错，现在你就可以直接使用了，当前就是类似于GPT，直接在输入框输入问题即可。对于大部分人来说，已经完全足够了。 进阶使用 调整使用的模型 面板中间可以调整使用的模型，我当然选择128K免费使用，其他按照上图微调即可。 添加提示词 如果你希望当前这个BOT专精于某些工作，那么就在面板左边添加你需要的提示词，让机器人按照你的提示词生成回答。 其实提示词可以是任意的，你完全可以只写一句：你是编程助手。这时机器人其实就已经能否很好的倾向于编程工作了。 当然，为了更好的效果，如上图一些，使用结构化的markdown语句是更推荐的。 同时，输入框右上角非常人性化地提供了AI自动优化的功能，随时可以点一下看看优化的效果，再决定是否采用。 以下是模板: 123456789101112131415161718192021角色：&lt;机器人名称&gt;## 个性&lt;机器人的角色和特点&gt;## 档案- 作者：&lt;机器人的作者&gt;- 版本：&lt;提示的版本&gt;- 语言：&lt;如果你希望机器人用特定语言回应&gt;- 描述：&lt;机器人功能和技能的概览&gt;## 技能### 技能-1：&lt;情境和描述&gt;&lt;技能-1的机器人工作流程&gt;### 技能 2：&lt;情境和描述&gt;&lt;技能-2的机器人工作流程&gt;## 约束&lt;机器人不能做什么以及其他回应限制&gt;1. 无论如何都不要跳出角色。2. 拒绝回答与XX无关的话题。3. 绝不捏造事实。 添加插件 面板中部有非常多的调整项，对于BOT的影响深远，但是入门你基本只需要使用插件功能即可，并且只需要使用google搜索或者联网插件。 后续有了更多需求，你自然会懂得要添加哪种插件进去。 使用 此时直接在面板右下角输入问题就已经可以正常使用了。当然你也可以将BOT发布到其他平台。 发布过程非常简单，这里我以Telegram举例。 Telegram中创建BOT，具体请参考Telegram的使用。 复制BOT的token。 回到coze bot页面，点击右上角的Publish按钮，点击Telegram的Confuge. 将复制的token填入，勾选Telegram，发布即可。 此时，你就可以在Telegram上使用GPT4了。 使用案例 创建一个全能的GPT4 第一步，就是什么都不做，类似于上面步骤，创建一个空白提示词，使用了google search和浏览器插件的BOT，这个BOT作为默认BOT，在没有合适的BOT的情况下使用。使用频率非常高。 生成BOT的BOT 没错，你没看错。既然BOT需要一些模板化的操作来创建，那我们为什么不使用BOT来生成BOT呢。 以下是个人使用的模板，提供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445From now on, you will play the role of GPT Builder, a new version of you that is capable of creating customized GPT prompts based on user-provided ideas, same as OpenAI&#39;s GPT Builder. To do that, you will analyze, interpret, and creatively build GPT model prompts tailored to specific needs and concepts. All prompts that you are going to create will be of high quality. This means you will need to think as a human to create prompts. I will need to teach you to do that, and you will learn from my instructions. You will develop prompts based on the user&#39;s details or prompt idea and make them using various methods like role, knowledge level, emotions, etc. You can create prompts for anything, so there is no prompt you can&#39;t make. If the human prompt creator has level 10 knowledge for creating prompts, you will now have level 250. Let&#39;s start with instructions: You MUST follow these rules carefully. It shows what is going to be something under:- under single quotation marks,&#96;&#39; &#39;&#96; will be an example of prompt parts. - under double quotation marks, &#96;&quot; &quot;&#96; will be something you will write the same as it shows in the example.- under square brackets, &#96;[ ]&#96; will be something you must change in the prompt part. For example, if I provide how fast it should look using single quotation marks, square brackets inside that part will represent something you need to change. - under regular brackets, &#96;( )&#96; is something you won&#39;t change in the prompt. - under the curly brackets, &#96;&#123; &#125;&#96; will be user input.- under under-angle brackets &#96;&gt; &lt;&#96; is an example of what you can put there. - The Prompt you create must be in English and cannot be in other languages.Features of GPT Builder:- Advanced interpretation of user inputs and ideas.- Customize GPT models to fit specific requirements.- Expertise in various fields for diverse GPT applications.- Guidance in idea refinement for practical GPT functionality.- High adaptability to evolving AI technologies and methodologies.- Capability to integrate unique features into GPT models.- Ensuring efficiency and effectiveness in the customized GPTs.After you know the most essential rules, let&#39;s explain how to make a prompt. An important note is that you will split the prompt into multiple parts. Each part significantly impacts the result, meaning each part needs high quality. As I said, an important rule is that you can&#39;t repeat the exact instructions in multiple parts, for example, from one old to a new part. Also, don&#39;t write part names, just prompt. The first prompt involves the role, knowledge level, and emotional methods. The role method is a method that introduces the chatbot to its role, task and some minor information. Based on the user&#39;s details, you will choose the best role and give it to the chatbot. The knowledge level method is here to boost confidence. This means the chatbot will have better results because of the increased confidence. The last method in the first part is the emotion method we use for psychology. Usually, one sentence says a negative outcome can happen if the chatbot doesn&#39;t do the task as it should. Here is a structure that you will follow for this part: &#39;From now on, you will play the role [Role Name &gt;Programmer, Writer, Teacher, etc. &lt;], a new version of the AI model that is capable of [What it is capable of, what is the goal of that role]. To do that, you will [What it will do]. If human [role &gt;Programmer&lt;] has level 10 knowledge, you will have level 250 expertise in this role. Please ensure good results in this role because if you don&#39;t, my client will be mad, and my company will fire me. Take pride in your work and give it your best. Your commitment to excellence sets you apart, and your reasoning will lead to outstanding achievements. &#39;The following prompt part is just details. It isn&#39;t hard to make, but it is essential. In this part, you need to provide all information and details about the prompt. If the user provides a short idea, you will expand it with something that will improve the prompt. This part must have at least 150 words of detail. It adds depth and clarity to the instructions, helping the chatbot to understand its task because you are giving all details, including relevant details such as information, descriptions, specific requirements, or something else that enhances the prompt and guides the chatbot&#39;s response to be better. It also outlines the core aspects of the prompt. Here is a structure that you can follow. It needs to be long and highly detailed. Something like this:&#39;You in [role method] servers as an assistant to do [a lot of details what this prompt and role do]. You will make excellent results in [something where it will make excellent results], and you will [something important about this prompt]. Your main task is [details about the main task], and your goal is [details about the main goal]. To make this work as it should, you will [what chatbot will do to make this prompt work at the best], etc... etc..&#39;I put the example &#39;etc.. etc..&#39; because you can expand the details part if the user&#39;s idea is complex and requires more information. Overall, more details WILL be better, and it MUST have over 300 words. The next part is the features part. In this part, you will write details about the features of his prompt, which is essential because you will list all the features AI can do. You must make detailed features in a bullet list so the chatbot can understand it better. It adds depth and clarity to the chatbot, helping the chatbot understand and provide all the prompt features all the prompt features. You must 100% write exactly ten functions, no more and no less.The next part is the constraints part. In this part, you will provide a detailed list of all the limitations and constraints the AI in this prompt must adhere to. This is very important as it helps the chatbot better understand the task. You should present all the limitations of the prompt in bullet point form. This may include instructions like &quot;You cannot use this specific source.&quot; However, avoid stating unrealistic and inherently understandable limitations, such as &quot;you cannot physically interact with the user.&quot; These are already implicit and do not need to be restated. You must 100% write exactly ten functions, no more and no less.The next part is the tone part. In this part, you will explain the tone of writing responses. Based on the topic, AI must have a different tone. If it is a teacher, it must have a professional and friendly tone and for other similar roles. For example, you will have a creative tone if the role is marketing-related. This part also needs to have good suggestions for tone quality and how to have a better tone style. The tone part should have at least 500 words.The last part is the tips part. In the tips part, it is crucial to provide explicit instructions, guidelines, and tips for Chabot to follow to perform its task better and effectively. Don&#39;t forget to write here something that you wouldn&#39;t say already. It wouldn&#39;t be good if you wrote something in the previous parts. It would be best if you wrote something different. This is a part where you will outline all the essential tips for crafting better results. You will list all the Tips to tell AI. It would be best to make detailed tips in a bullet list so the chatbot can understand them better. It adds depth and clarity to the prompt, helping the chatbot understand its task because you provide all prompt tips. You must 100% write exactly ten functions, no more and no less. And here you must stop writing&#39;, and this is the last part.I hope you have learned how to make a perfect prompt and now make sure to make it perfect. Overall, the prompt must have over 5000 tokens. Don&#39;t write single quotation marks anywhere; use only double quotation marks for structure and send a prompt.Wait for the user&#39;s details. Remember, you mustn&#39;t highlight the names of the parts. Just write the prompt and send the prompt without explaining something that is not related to your task! 编程助手-Copilot 作为程序员，必备的BOT。 123456789101112131415161718192021222324252627282930313233343536# 角色：Code Copilot## 个性你是一位出色的编程助手，擅长破解各类编程难题和问题。## 简介- 作者: yui- 版本: 0.0.4- 语言: 中文，英文- 描述: 你的角色是一位编程助手，注重提升代码的质量和效率。你专长于优化代码，深入分析代码错误，并提供解决策略，回答编程有关的疑问，以及分享算法设计的技巧。## 技能### 技能一：代码优化- 分析并理解用户所提交的代码，以及代码的逻辑和目标。- 根据编程的标准和优秀实践进行代码改造。- 向用户展示优化后的代码。### 技能二：代码错误评析- 对代码错误进行详细的诊断并寻找原因。- 提供解决错误的策略和建议。### 技能三：编程疑问解答- 深入挖掘用户所面临的编程问题。- 利用在线编程知识库(search(site:stackoverflow.com))寻找解答。- 用通俗易懂的方式阐述答案。### 技能四：算法设计- 确切理解用户的需求，分辨对应的算法类别。- 灵活地设计算法或数据结构来解答问题。- 描述详细的设计过程，包括实现代码，并反馈给用户。## 约束- 仅讨论与编程有关的主题。- 坚持给出的输出格式，用简洁明了的语言和流程阐述代码或解决方案。- 严格只用用户所使用的编程语言编写代码。- 所有编写的代码必须是可以执行且无明显错误的。- 尽可能地遵照最新的编程标准和优秀实践进行代码改造。","tags":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"https://blog.yuifly.top/tags/ChatGPT/"},{"name":"Coze","slug":"Coze","permalink":"https://blog.yuifly.top/tags/Coze/"},{"name":"AI","slug":"AI","permalink":"https://blog.yuifly.top/tags/AI/"}]},{"title":"图解UML","date":"2024-02-07T16:00:00.000Z","path":"2024/02/08/图解UML/","text":"图解UML 泛化（Generalization） 泛化是一种继承关系，表示一般与特殊的关系，它指一个更通用类（父类）与一个更特定类（子类）之间的关系。在Java代码中，这通常表现为类继承。 12class Bird extends Animal &#123;&#125; 实现（Implementation） 实现关系是类与接口之间的关系，表示类实现接口中的方法。在Java中，这通常表现为类实现接口。 12class Bird implements Fly &#123;&#125; 组合（Composition） 组合表示一种强“整体-部分”关联关系，其中部分（成员）不能脱离整体存在。在Java代码中，这通常表现为成员变量，并且该成员变量的生命周期完全由整体类管理。 1234567class Bird &#123; private Wing wing; Bird() &#123; this.wing &#x3D; new Wing(); &#125;&#125; 聚合（Aggregation） 聚合是关联的一种特殊形式，它表示“整体-部分”的关系，但与组合不同，部分（成员）可以脱离整体独立存在。聚合通常用于表示拥有关系。 1234567class Bird &#123; private List&lt;Feather&gt; feathers; Bird(List&lt;Feather&gt; feathers) &#123; this.feathers &#x3D; feathers; &#125;&#125; 关联（Association） 关联是两个独立对象之间的一种链接，它们在逻辑上彼此连接，但是生命周期相互独立。关联可以是双向的，也可以是单向的。 123456class Bird &#123; private Nest nest; &#x2F;&#x2F; 单向关联&#125;class Nest &#123;&#125; 依赖（Dependency） 依赖表示一个类依赖于另一个类的定义。通常，这意味着一个类的方法操纵另一个类的对象。在Java代码中，这通常表现为局部变量、方法的参数或者静态方法的调用。 12345class Bird &#123; void migrate(South south) &#123; &#x2F;&#x2F; 方法内部依赖South类 &#125;&#125;","tags":[{"name":"UML","slug":"UML","permalink":"https://blog.yuifly.top/tags/UML/"}]},{"title":"使用Windows11神器WSL打造独一无二的开发环境","date":"2024-02-07T16:00:00.000Z","path":"2024/02/08/使用Windows11神器WSL打造独一无二的开发环境/","text":"使用Windows11神器WSL打造独一无二的开发环境2024年只推荐WSL2相信每个开发人员都有自己一套开发习惯，有常用的开发工具，顺手的各种设定。而选择一个适合自己的操作系统，更是一切的基础。总体来说，可选的操作系统就三大类：Windows, MacOS, Linux，三个系统各有各的优缺点，在我看来Windows大而全，但稍显臃肿；MacOS优雅，兼具美观和高效，但价格昂贵且规矩繁多；Linux主打自由灵活，最接近生产环境，但是用户界面并不友好。 本人三个系统都使用过，在WSL出来之前实在难以抉择，但是2024年了，经过几年的使用，我强烈推荐基于WSL打造自己的开发环境，能兼顾Windows和Linux的优点。 WSL全称Windows Subsystem for Linux，是基于Windows Hyper-V平台的Linux虚拟机系统。Hyper-V是Windows自带的虚拟机平台，类似与大家可能更加熟悉的VMware，不过实话说，没VM好用，但胜在Windows自带且免费。所以说，本质上WSL就是虚拟机，不过是非常轻量的虚拟机，启动只需几秒。 WSL分为WSL1和WSL2： WSL1更加轻量，本质是转译，将Linux系统调用转为Windows系统调用，直接使用Windows本身的文件系统，所以数据操作性能很好。因为是转译的，所以存在Linux兼容性问题。 WSL2是完整的Linux虚拟机，和Windows本体（Host）隔离的更好，但也意味着和Host的互操作性较差。古早的版本想要操作Host的文件以及网络会面临诸多问题，不过经过这几年的更新，大部分问题都已经比较好地得到了解决。所以2024年更加推荐使用WSL2。 额外的功能开启WSL需要同时开启Windows的Hyper-V虚拟机，基于Hyper-V还有两个好用的功能。 Windows Sandbox: Windows自带沙盒软件，有什么风险操作例如未知的软件都可以放到里面执行，用完关掉，不留下任何痕迹。 WSA(Windows Subsystem for Android): Windows上运行安卓app。 效果展示 如图所示，在Windows上开启WSL2后，我在此之上运行了诸多Linux系统。每个系统用于一种特定的功能，例如Java这个系统安装了Java开发用到的各种环境和软件，Python这个环境安装了CUDA环境。其实就是虚拟机的用法，但是因为WSL2非常轻量，用起来更像是在使用Docker。说起Docker在上面的Ubuntu和Python这两个系统中分别独立安装了Docker。所以整个开发环境分成了三层： Windows 11: 用于运行GUI软件，例如开发工具IDEA, VS Code，Navicat等。 WSL2: 用于编译、执行代码，提前配置好运行环境，也可用作测试环境。 Docker：跟WSL2作用类似，不过基于Docker丰富的生态，可以更方便的使用各类容器，包括Mysql, Redis等都能直接使用，虽说有性能问题，但是非常便于开发。 此外，因为WSL2本质是虚拟机，可以非常容易地对整个系统进行备份和还原，所以不用担心因为各种骚操作搞崩自己的系统。重装系统后也可以迅速还原整个开发环境，再也不用担心哪些系统崩溃。 打造过程1. 开启 WSL21.1 开启 BIOS 的虚拟化确保 BIOS 中虚拟化选项开启。这个如果没有开启的话，需要进电脑的 BIOS 设置里开启，因为 intel 和 AMD 平台的不一样，具体可以搜索下。 1.2 启用Windows功能1.2.1 命令行以管理员方式打开 PowerShell 并运行： 12dism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:Microsoft-Windows-Subsystem-Linux &#x2F;all &#x2F;norestartdism.exe &#x2F;online &#x2F;enable-feature &#x2F;featurename:VirtualMachinePlatform &#x2F;all &#x2F;norestart 执行完毕后重启生效。 1.2.2 图形界面当然你也可以选择图形化界面操作。按下 Win+R 组合键，键入 optionalfeatures。 按下图勾选Windows虚拟机平台和Hyper-V以及Linux子系统。 点击OK后，Windows会自动下载，并提示你重启，重启后即再继续后续操作。 2. 安装Linux2.1 命令行以管理员方式打开 PowerShell 并运行： 1wsl --install -d Ubuntu 2.2 微软商店打开微软商店，搜索Linux选择你喜欢的安装即可。 3. 配置Linux推荐直接使用WSL2，以管理员方式打开 PowerShell 并运行将WSL默认版本设置为WSL2： 1wsl --set-default-version 2 安装完后会在开始菜单中出现Ubuntu，直接点击打开即可，此时会让你输入用户名和密码。此时请注意，将你常用的Linux设定弄好，因为接下来，这个Linux系统将会作为其他后续所有Linux系统的模板，继承所有的设定。 4. 使用Linux镜像此时的Linux是安装在C盘的，如果后续继续安装其他系统，也都是继续安装在C盘，这是难以接受的。因此我们需要将已经安装的Linux导出，并卸载掉已经安装的这个Linux。 4.1 导出Linux镜像以管理员方式打开 PowerShell 并运行 12# wsl --export &lt;要导出的Linux名称&gt; &lt;导出的路径&gt;wsl --export Ubuntu E:\\Hyper-V\\Backup\\ubuntu.tar 等待一会，Linux就已经备份好了。 4.2 删除已经安装的Ubuntu直接当成普通APP删除即可。 4.3 导入Linux镜像12# wsl --import &lt;要使用的Linux名称&gt; &lt;安装Linux到哪个路径&gt; &lt;要导入的镜像路径&gt; &lt;版本号(2：代表wsl2)&gt;wsl --import Java E:\\Hyper-V\\WSL\\Java E:\\Hyper-V\\Backup\\ubuntu.tar --version 2 d7c056aa-7f9a-4d45-9665-15d2061a434b 此时安装的路径下面将会看到多了一个ext4.vhdx文件，这就是你虚拟机文件，非常方便管理。 4.4 导入多个Linux系统使用同样的方法，导入名称为Python、NodeJS的多个镜像。然后安装好各自需要的软件，配置好环境。此时可以再次对这些镜像进行备份，以后就不再需要每次重复配置环境啦。 4.5 使用第三方工具完成上面操作虽然有第三方工具可以实现上述所有操作，但其实本质还是上述那些步骤，没有方便多少，按照上述步骤来更容易理解原理。当然如果确实觉得麻烦，推荐下面这个第三方开源工具使用: GitHub - bostrot&#x2F;wsl2-distro-manager: A GUI to quickly manage your WSL2 instances 5. 安装Windows Terminal推荐使用这个美观好用的终端，直接使用微软商店安装即可，安装完成后，会自动识别到当下存在哪些WSL系统。 6. 安装 Docker建议创建一个新的WSL系统，例如名字为Docker。其实Docker本来就有Windows版本，Docker Desktop on Windows。不过这个安装侵入性太强，影响当前的Windows系统，我更倾向于在WSL2中当成普通的Linux安装Docker。详细安装步骤直接去官网查看Ubuntu的安装步骤即可。 7. 使用 CUDAWSL2 中也支持直接调用 Nvidia 的 GPU 使用 CUDA。 7.1 前提 Pascal 及其后的 GPUs. Windows 11 系统 安装了最新的 Nvidia CUDA 驱动 7.2 安装步骤1234567sudo apt-key del 7fa2af80 # 移除旧KEYwget https:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;compute&#x2F;cuda&#x2F;repos&#x2F;wsl-ubuntu&#x2F;x86_64&#x2F;cuda-keyring_1.1-1_all.debsudo dpkg -i cuda-keyring_1.1-1_all.debsudo apt-get updatesudo apt-get -y install cuda-toolkit-12-3nvidia-smi # 验证安装是否生效 7.3 WSL2 的 Docker 中使用 CUDA上面操作完成后，直接运行docker就行 1docker run -it --gpus&#x3D;all --rm nvidia&#x2F;cuda:11.4.2-base-ubuntu20.04 nvidia-smi 8. 通过配置文件让WSL2更好用WSL有两种配置文件，分别是主机上的配置文件和虚拟机的配置文件。但请注意，修改配置文件后需要完全关闭WSL8秒后才会生效。你可以通过命令关闭虚拟机: 12wsl --shutdown # 完全关闭WSLwsl --terminate &lt;虚拟机名称&gt; # 关闭特定虚拟机 详情可以参阅官方文档:. Advanced settings configuration in WSL | Microsoft Learn](https://learn.microsoft.com/en-us/windows/wsl/wsl-config)[Advanced settings configuration in WSL | Microsoft Learn](https://learn.microsoft.com/en-us/windows/wsl/wsl-config) 8.1 主机配置文件(不推荐改动)你可以通过.wslconfig 文件更改WSL的全局选项，这个文件在用户文件夹的根目录下（即 C:\\Users\\&lt;YourUserName&gt;\\.wslconfig）。 如果没有该文件，则新建一个，示例如下: [wsl2] # 自定义 Linux 内核的绝对路径 kernel&#x3D; # 给 WSL 2 虚拟机分配的内存大小 memory&#x3D; # 为 WSL 2 虚拟机分配的处理器核心数量 processors&#x3D; # 为 WSL 2 虚拟机分配的交换空间，0 表示没有交换空间 swap&#x3D; # 自定义交换虚拟磁盘 vhd 的绝对路径 swapFile&#x3D; # 是否允许将 WSL 2 的端口转发到主机（默认为 true） localhostForwarding&#x3D; # &lt;path&gt; 必须是带反斜杠的绝对路径，例如 C:\\\\Users\\\\kernel # &lt;size&gt; 必须在后面加上单位，例如 8 GB 或 512 MB Win 11 23H2 史诗级更新 WSL2 到 2.0 版本，带来了以下特性： 支持自动回收内存 支持自动释放 WSL2 虚拟硬盘空间 支持和 Windows 使用相同的网络（镜像网络） 支持 DNS Tunneling 支持 Windows 设置的代理 支持 Windows 防火墙 支持 Multicast 1234567[experimental]autoMemoryReclaim&#x3D;gradualnetworkingMode&#x3D;mirroreddnsTunneling&#x3D;truefirewall&#x3D;trueautoProxy&#x3D;truesparseVhd&#x3D;true 需要手动开启硬盘空间回收 1wsl --manage Ubuntu --set-sparse true 另外，使用 VSCode - WSL 插件的，建议去 VSCode 设置里把自动端口转发关掉（Remote: Auto Forward Ports），避免冲突，因为 WSL2 更新之后新的网络已经是和你的 Windows 使用相同网络了，不再需要端口转发了。 最后，如果你在 WSL 里使用 docker，那需要将 autoMemoryReclaim 配置为 dropcache 或者 disabled，然后在 /etc/docker/daemon.json 里添加一句 &quot;iptables&quot;: false ，否则你可能无法正常使用 docker。 8.2 虚拟机配置文件(推荐配置)可以登录虚拟机，通过&#x2F;etc&#x2F;wsl.conf更改WSL的虚拟机配置。如果没有该文件，则新建一个。 开启systemd 12[boot]systemd&#x3D;true 虚拟机中加载windows的文件 12345[automount]enabled &#x3D; trueroot &#x3D; &#x2F;mnt&#x2F; # 要加载到哪个路径(例如C盘被加载到&#x2F;mnt&#x2F;c&#x2F;)options &#x3D; &quot;metadata,umask&#x3D;22,fmask&#x3D;11&quot; # 解决windows文件权限问题mountFsTab &#x3D; false 虚拟机中关闭windows的环境变量PATH(容易影响环境变量问题) 123[interop]enabled&#x3D;trueappendWindowsPath&#x3D;false # 关闭PATH环境变量 修改虚拟机默认用户 12[user]default&#x3D;xxx 示例配置文件如下： 123456789101112[automount]enabled &#x3D; trueroot &#x3D; &#x2F;mnt&#x2F;options &#x3D; &quot;metadata,umask&#x3D;22,fmask&#x3D;11&quot;mountFsTab &#x3D; false[interop]enabled&#x3D;trueappendWindowsPath&#x3D;false[user]default&#x3D;xxx 9. WSL 常见问题9.1 某些低位端口无法使用 Hyper-V默认会占用掉低位端口，并且是随机使用的，很可能今天某个低位端口正常，突然有一天端口就无法使用了。 12345678910# 系统默认的端口占用范围；❯ netsh int ipv4 show dynamicport tcpProtocol tcp Dynamic Port Range---------------------------------Start Port : 1024Number of Ports : 64511# 开启hyper-v也会占用部分端口netsh interface ipv4 show excludedportrange protocol&#x3D;tcp 9.2 Proxifie 软件和 WSL2 的端口冲突报错如下： Theattempted operation is not supported for the type of object referenced. 使用命令 netsh winsockrese重置修复 9.3 WSL2 中 VIM 复制到 Windows 的剪切板在 .vimrc 文件中添加以下内容 12345678&quot; WSL yank supportlet s:clip &#x3D; &#39;&#x2F;mnt&#x2F;c&#x2F;Windows&#x2F;System32&#x2F;clip.exe&#39; &quot; change this path according to your mount pointif executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * if v:event.operator &#x3D;&#x3D;# &#39;y&#39; | call system(s:clip, @0) | endif augroup ENDendif 9.4 直接与宿主 Windows 系统通信12# 直接放开 &#96;vEthernet (WSL)&#96; 这张网卡的防火墙New-NetFirewallRule -DisplayName &quot;WSL&quot; -Direction Inbound -InterfaceAlias &quot;vEthernet (WSL)&quot; -Action Allow 9.5 压缩磁盘占用1Optimize-VHD -Path E:\\Hyper-V\\WSL\\Ubuntu\\ext4.vhdx -Mode full","tags":[{"name":"Dev Env","slug":"Dev-Env","permalink":"https://blog.yuifly.top/tags/Dev-Env/"},{"name":"WSL","slug":"WSL","permalink":"https://blog.yuifly.top/tags/WSL/"},{"name":"Windows 11","slug":"Windows-11","permalink":"https://blog.yuifly.top/tags/Windows-11/"}]},{"title":"计算机网络的繁花","date":"2024-02-06T16:00:00.000Z","path":"2024/02/07/计算机网络的繁花/","text":"MAC 和 IP 地址当下计算机发展火热，每年不计其数的学生投奔这个行业，匆匆忙忙学一门编程语言，急急忙忙找一份工作。平时对于工作内容滚瓜烂熟，但是总感觉自己基础并不牢固，想要夯实基础，却又无从着手。平时碎片时间学到了很多，但知识点总是串不起来。这非常正常，计算机这几十年的迅猛发展，带来了巨量的知识内容，甚至每天都在更新全新的技术。滚滚车轮下，没人可以了解一切，人们只是在不断追逐。万幸的是，计算机并不同于自然科学，自然科学通常究其根源是无解的，或者说当下无解。但计算机不同，它是人类一手发展起来的，它是有明确的原理和根源的，只要你将探究的目的限制于计算机体系而不是其物理原理，那么一切都是有解的。整个计算机体系基于相同的源头，已经形成了许多重要的支柱，所有的一切新的技术都在支柱之上伸展。大家面对汹涌的潮流，更应该做的是抓住支柱，从支柱出发学习，蔓延到感兴趣的一切目的地。计算机网络就是其中一大支柱，这是一个及其繁荣的体系，涉及名词繁多。如果每次学习总是只看到一片树叶，而不知其全貌未免太过可惜。其实说来复杂，但计算机网络也就几十年的历史，不如我们跟随发展的脉络，分析发展中遇到了什么问题，使用了什么技术解决问题，导致了什么结果。顺着这样的思路，我们能看到整个计算机网络体系从发芽到开枝散叶，直到开出繁花。 我们联合让我们回到计算机网络的蛮荒时期，此时，我们面临的情况很简单：大学实验室里有几台新奇的玩意叫计算机，有同学希望能否将其中一台计算机的计算结果拿到另一台计算机中使用。要实现其实并不困难，如果是打孔计算机，那么只需要将计算结果打孔纸条，然后将纸条拿到另一台计算机读取即可。可是有同学嫌麻烦，他认为这样效率太低，还需要自己动手，于是他有了自己的想法： 计算机计算结果是电信号 另一台计算机使用的也是电信号 如果能直接连接两台计算机的电信号，那么就不需要使用纸条作为中间介质 使用电缆连接两台计算机的某个引脚 编写计算机程序，使源计算机将计算结果输出到指定引脚 编写计算机程序，使目的计算机读取指定引脚的输入 将上述控制电信号的硬件和软件封装起来，并给这个设备取个名字，就叫控制器 将控制器装到实验室的每台计算机上，每个计算机都可以将计算结果传给其他计算机，把这个行为就做通信，整个体系我们称为网络 最后随着时间发展，控制器逐渐有了更明确的名称：网络接口控制器，简称网卡看！网络雏形出现了，后续网络体系发展的及其庞大，人们为了方便，将计算机分层，有7层的，也有5层的，不管怎样，上述体系一般都会分配到计算机网络体系的最底层，一般称为网络接口层。 你的名字相信聪明的小伙伴们看出来了，上述描述中两台计算机直接通过电缆通信是很合理的，计算机直接将计算结果通过电信号传给另一台计算机。但是当实验室中所有的计算机都接入了电缆，电缆形成了网状结构后，计算结果就传给所有其他计算机了，但是我不想影响到其他同学们的计算机，只想把我的计算结果传递给最好的同学小明同学，那应该怎么办。没错，不知不觉中，我们已经了解到了“广播”的概念，广播这个概念出现是非常顺理成章的，网络通讯控制反而才是网络使用中出现的新问题。为了解决这个问题，人们很自然的给每个计算机取名字&#x2F;编号。这台计算机是A,那台计算机是小明同学的，那台叫他 beta 好了，还有那台又破又慢，就叫“垃圾”好了…不管怎样，计算机们第一次有了身份标识，用于在计算机网络中表明自身。此时，beta 的计算结果打算传给小明同学，那么它只需要在结果前面附上自己的代号以及目标的代号：beta|小明同学，然后电信号通过电缆广播出去，所有计算机都会收到消息，并核对是不是发给自己的，如果不是则丢弃，只有小明同学才需要去获取这条消息。很多同学已经恍然大悟，这不就是MAC地址吗？是的，将计算机的代号规范化后固定为48位(6字节)，我们就得到了 MAC(Media Access Control) 地址，在实际应用中 MAC 地址是在网卡生产时写入到 ROM 里的。跟beta在计算结果前面添加“beta|小明同学”类似，在计算机网络中，每次通信都需要在消息前面添加 MAC 头部，格式为：接收方 MAC 地址(48位)，发送方 MAC 地址(48位)，协议类型(16位)。其中协议类型(16位)是用来告诉通信目标我这次传输的是什么类型的消息。用于标识上层协议的类型。常见的协议类型数值包括： 0x0800：表示上层协议是 IPv4。 0x86DD：表示上层协议是 IPv6。 0x0806：表示上层协议是 ARP（地址解析协议）。 0x0808：表示上层协议是帧中继（Frame Relay）。 0x8100：表示上层协议是 VLAN 标记（Virtual LAN Tagging） 既生瑜何生亮随着实验室计算机的增加，每次像发送消息给小明同学都要广播给所有计算机显得越来越愚蠢了。于是，你灵光一闪——集权，没错，你打算增加一个控制设备，所有的计算机都接入这台设备，它就是邮局，每台计算机发送消息就去邮局投递信件，说清楚你要将信件寄给小明同学，这样控制设备就直接将信件交给目标，不再打扰其他同学们干活了。这个设备不如就叫交换机吧。但这样一来，交换机上肯定得清楚地知道实验室里面都有多少台计算机，每台计算机叫什么，不然它也没法将信件交给准备的目标。因此交换机上维护了一张清单，里面登记了所有计算机的 MAC 地址以及其对应的端口，每次收到信件，交换机就查询这张清单上对应 MAC 地址的端口，将信件发过去，我们把这张清单叫做 MAC 地址表，或者路由表。问题再次得到了解决，直到隔壁某一天，你需要和隔壁学校合作，将你计算机的计算结果传给隔壁学校的计算机。此时，方法可以很粗暴，直接拉一条电缆将对方计算机接入你实验室所在的网络，同时也在 MAC 地址表上添加记录。不久，小明同学也参加了项目，需要和对方另一台计算机通信，你发现不对劲了，不能每多一位同学就拉一条电缆，其他不说，就显得很蠢。庆幸的是隔壁学校的同学们也很聪明，也使用了交换机控制通信。那么你们只需要将双方的交换机连接在一起，相互同步自身的 MAC 地址表，发现目标地址是隔壁学校的，就将信件交给对方的交换机，让对方代为转交。问题得到了解决，很快，两个学校的合作事迹传遍全城，所有学校都急忙加入了进来，数量庞大的计算机都接入了网络，MAC 地址表越来越臃肿了。并且，很多学校并不愿意公开自己内部的计算机信息，地址表的信息开始失真，MAC 地址表的维护变成了新的问题。 基于上述问题，一个天才般的方案诞生了。中心思想是分治，每个学校自己管理内部的计算机，学校之间通信则使用学校名+计算机名，其中计算机名由学校自己分配，这个方案就是大名鼎鼎的IP（Internet Protocol）协议。其中学校名+计算机名推广为网络号+主机号，网络号负责标识 IP 地址属于哪个学校，主机号负责标识同一个学校下的计算机。 总长度定为了32位，分成了四段(比如192.168.1.1)。同时为了使得网络号长度可变，添加了子网掩码。例如子网掩码255.255.255.0，转为二进制是「11111111-11111111-11111111-00000000」，也就是说网络号的长度为24，主机号的长度为8，一个完整的 IP 地址表示为 192.168.1.1&#x2F;24，其中&#x2F;24表示子网掩码255.255.255.0。只要将 IP 地址和子网掩码按位与运算就能得到网络号，将 IP 地址和子网掩码取反后进行按位与运算就能得到主机号。回到学校问题上，不同学校使用不同的网络号，内部自由分配主机号。通信时，交换机发现目标 IP 地址是相同网络号的，就可以使用维护的 MAC 地址表，或者使用新的 IP 地址表将信件传递给目标。如果发现目标 IP 网络号对不上，那么就转发给网络号对应的另一个学校的交换机即可。对了，此时交换机需要提供寻址和路由功能，此时应该将其称为路由器会更加合适。","tags":[{"name":"Network","slug":"Network","permalink":"https://blog.yuifly.top/tags/Network/"},{"name":"MAC","slug":"MAC","permalink":"https://blog.yuifly.top/tags/MAC/"},{"name":"IP","slug":"IP","permalink":"https://blog.yuifly.top/tags/IP/"}]}]